"""
pesr_integration.rules
Matthew Stone <mstone5@mgh.harvard.edu>

Cluster SV after filtering based on PE, SR, RD, and BAF evidence. 
"""

import pandas as pd

with open(config['groups']) as glist:
    GROUPS = [g.strip() for g in glist.readlines()]

PESR_SOURCES = config['pesr_sources']

localrules: all, make_vcf_list

rule filter_vcfs:
    input:
        vcf='unfiltered_vcfs/{batch}.{source}.{chrom}.vcf',
        cnv='combined_CNV.passing.p',
        bca='combined_BCA.passing.p'
    output:
        vcf='filtered_vcfs/{batch}.{source}.{chrom}.vcf.gz',
        tbi='filtered_vcfs/{batch}.{source}.{chrom}.vcf.gz.tbi'
    shell:
        # awk '(($2=="Pass" || $2=="NA") && 
        #       $3=="Pass" && 
        #       $4=="Pass" &&
        #       ($5=="Pass" || $5=="NA"))' {input.metrics} \
        # fgrep -e "Pass" {input.metrics} \
        # awk '(($3=="Pass" || $4=="Pass") && ($5=="Pass"))' {input.metrics} \
        #     <(awk '(($3=="Pass" || $4=="Pass") && ($5=="Pass"))' {input.cnv_metrics}) \
        #     <(fgrep -e "Pass" {input.bca_metrics} | sed -e 's/ /\\t/g') \
        # cat \
        #     <(awk '(($3=="Pass" || $4=="Pass") && ($5=="Pass"))' {input.cnv_metrics}) \
        #     <(fgrep -e "Pass" {input.bca_metrics} | sed -e 's/ /\\t/g') \
        # # Size filter
        #   | awk '{{split($8, info, ";");
        #            split(info[1], svtype, "=");
        #            split(info[7], svlen, "=");
        #            if (svtype[2] == "BND" || svtype[2] == "INV" || svlen[2] >= 1000 || $1 ~ "^#") {{
        #              print $0;
        #            }};
        #          }}' \
            # <(sed -e '1d' {input.passing} | cut -f1) \
            # <(fgrep -e "Pass" {input.bca_metrics} | sed -e 's/ /\\t/g' | cut -f1) \
        """
        cat <( sed -e '1d' {input.cnv}) <(sed -e '1d' {input.bca}) \
          | cut -f1 \
          | fgrep -w -f - {input.vcf} \
          | cat <(sed -n -e '/^#/p' {input.vcf}) - \
          | vcf-sort -c \
          | bgzip -c \
          > {output.vcf};
        tabix -f -p vcf {output.vcf}
        """

def get_batch_vcfs(wildcards):
    """Collect all VCFs for a batch/chrom pairing across sources"""

    if wildcards.sources == 'pesr':
        vcf_path = 'filtered_vcfs/{batch}.{source}.{chrom}.vcf.gz'

        return [vcf_path.format(batch=wildcards.batch, source=source,
                            chrom=wildcards.chrom)
                for source in PESR_SOURCES]
    elif wildcards.sources == 'pesr_depth':
        return ['vcfcluster/pesr/{batch}.{chrom}.vcf.gz'.format(**wildcards),
                'filtered_vcfs/{batch}.depth.{chrom}.vcf.gz'.format(**wildcards)]

# Make list of all algorithm VCFs for each batch/chrom combo
rule make_vcf_list:
    input:
        get_batch_vcfs
    output:
        vcflist='vcflists/{sources}/{batch}.{chrom}.list'
    run:
        with open(output[0], 'w') as fout:
            for fname in sorted(input):
                fout.write(fname + '\n')

# Cluster VCFs across algorithms
rule vcfcluster:
    """Cluster calls from a single algorithm across samples."""
    input:
        vcflist=rules.make_vcf_list.output.vcflist
    output:
        vcf='vcfcluster/{sources}/{batch}.{chrom}.vcf.gz',
        tbi='vcfcluster/{sources}/{batch}.{chrom}.vcf.gz.tbi',
    params:
        vcfcluster=lambda wildcards: config['vcfcluster'][wildcards.sources],
        prefix=lambda wildcards: '{0}'.format(wildcards.batch)
    shell:
        """
        svtools vcfcluster {input} stdout \
            -p {params.prefix} \
            -d {params.vcfcluster[dist]} \
            -f {params.vcfcluster[frac]} \
            -x {params.vcfcluster[blacklist]} \
            -z {params.vcfcluster[svsize]} \
            -t {params.vcfcluster[svtypes]} \
          | vcf-sort -c \
          | bgzip -c > {output.vcf};
        tabix -p vcf {output.vcf};
        """

rule link_cpx:
    input:
        vcf='vcfcluster/pesr_depth/{batch}.{chrom}.vcf.gz',
    output:
        bed='complex_linking/{batch}.{chrom}.resolved.vcf',
        unresolved='complex_linking/{batch}.{chrom}.unresolved.vcf',
    params:
        prefix=lambda wildcards: '{batch}_CPX_{chrom}'.format(**wildcards)
    shell:
        """
        svtools resolve -p {params.prefix} {input.vcf} {output.bed} -u {output.unresolved}
        """
